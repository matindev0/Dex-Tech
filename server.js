// ===== FILE-BACKED STATIC SERVER =====
// No database required. Data is persisted directly in project files.

const http = require('http');
const fs = require('fs');
const path = require('path');

const PORT = process.env.PORT || 3000;
const ROOT_DIR = __dirname;
const DATA_FILE = path.join(ROOT_DIR, 'assets', 'js', 'data.js');
const UPLOAD_DIR = path.join(ROOT_DIR, 'assets', 'images', 'uploads');

function ensureUploadDir() {
  if (!fs.existsSync(UPLOAD_DIR)) {
    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
  }
}

function sanitizeData(raw) {
  return {
    adminPin: String(raw && raw.adminPin ? raw.adminPin : '3003'),
    posts: Array.isArray(raw && raw.posts) ? raw.posts : [],
    settings: {
      adsenseCode: raw && raw.settings && typeof raw.settings.adsenseCode === 'string' ? raw.settings.adsenseCode : '',
      analyticsCode: raw && raw.settings && typeof raw.settings.analyticsCode === 'string' ? raw.settings.analyticsCode : '',
      lastModified: raw && raw.settings && raw.settings.lastModified ? raw.settings.lastModified : new Date().toISOString()
    }
  };
}

function loadData() {
  try {
    delete require.cache[require.resolve(DATA_FILE)];
    const loaded = require(DATA_FILE);
    return sanitizeData(loaded);
  } catch (_) {
    return sanitizeData(null);
  }
}

function buildDataSource(data) {
  return `// ===== EMBEDDED DATA STORAGE =====\n// Generated by server.js on ${new Date().toISOString()}\n\nconst EMBEDDED_DATA = ${JSON.stringify(data, null, 2)};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = EMBEDDED_DATA;\n}\n`;
}

function saveData(data) {
  const normalized = sanitizeData(data);
  fs.writeFileSync(DATA_FILE, buildDataSource(normalized), 'utf8');
  return normalized;
}

function sendJson(res, statusCode, payload) {
  res.writeHead(statusCode, { 'Content-Type': 'application/json; charset=utf-8' });
  res.end(JSON.stringify(payload));
}

function sendText(res, statusCode, payload) {
  res.writeHead(statusCode, { 'Content-Type': 'text/plain; charset=utf-8' });
  res.end(payload);
}

function readJsonBody(req, maxBytes = 12 * 1024 * 1024) {
  return new Promise((resolve, reject) => {
    let raw = '';
    req.on('data', (chunk) => {
      raw += chunk;
      if (Buffer.byteLength(raw) > maxBytes) {
        reject(new Error('Request body too large'));
        req.destroy();
      }
    });

    req.on('end', () => {
      if (!raw.trim()) {
        resolve({});
        return;
      }

      try {
        resolve(JSON.parse(raw));
      } catch (_) {
        reject(new Error('Invalid JSON body'));
      }
    });

    req.on('error', reject);
  });
}

function contentTypeFor(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  const contentTypes = {
    '.html': 'text/html; charset=utf-8',
    '.css': 'text/css; charset=utf-8',
    '.js': 'application/javascript; charset=utf-8',
    '.json': 'application/json; charset=utf-8',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
    '.ico': 'image/x-icon'
  };
  return contentTypes[ext] || 'application/octet-stream';
}

function normalizePostInput(input) {
  return {
    title: String(input && input.title ? input.title : '').trim(),
    description: String(input && input.description ? input.description : '').trim(),
    category: String(input && input.category ? input.category : '').trim(),
    youtubeEmbed: String(input && input.youtubeEmbed ? input.youtubeEmbed : '').trim(),
    thumbnail: String(input && input.thumbnail ? input.thumbnail : '').trim()
  };
}

function isValidPostInput(post) {
  return Boolean(post.title && post.description && post.category);
}

function sanitizeFilename(name) {
  return String(name || 'image')
    .toLowerCase()
    .replace(/[^a-z0-9._-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '') || 'image';
}

function parseDataUrl(dataUrl) {
  const match = String(dataUrl || '').match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,(.+)$/);
  if (!match) return null;
  return {
    mime: match[1].toLowerCase(),
    base64: match[2]
  };
}

function extensionFromMime(mime) {
  const map = {
    'image/png': 'png',
    'image/jpeg': 'jpg',
    'image/jpg': 'jpg',
    'image/gif': 'gif',
    'image/webp': 'webp'
  };
  return map[mime] || null;
}

async function handleApi(req, res, pathname) {
  try {
    if (req.method === 'GET' && pathname === '/api/data') {
      return sendJson(res, 200, loadData());
    }

    if (req.method === 'GET' && pathname === '/api/posts') {
      return sendJson(res, 200, loadData().posts);
    }

    if (req.method === 'GET' && pathname.startsWith('/api/posts/')) {
      const id = decodeURIComponent(pathname.slice('/api/posts/'.length));
      const post = loadData().posts.find((item) => String(item.id) === id);
      if (!post) return sendJson(res, 404, { error: 'Post not found' });
      return sendJson(res, 200, post);
    }

    if (req.method === 'POST' && pathname === '/api/posts') {
      const payload = normalizePostInput(await readJsonBody(req));
      if (!isValidPostInput(payload)) {
        return sendJson(res, 400, { error: 'title, description, and category are required' });
      }

      const data = loadData();
      const timestamp = new Date().toISOString();
      const newPost = {
        id: Date.now().toString(),
        title: payload.title,
        description: payload.description,
        category: payload.category,
        youtubeEmbed: payload.youtubeEmbed,
        thumbnail: payload.thumbnail,
        createdAt: timestamp,
        updatedAt: timestamp
      };

      data.posts.push(newPost);
      data.settings.lastModified = timestamp;
      saveData(data);
      return sendJson(res, 201, newPost);
    }

    if (req.method === 'PUT' && pathname.startsWith('/api/posts/')) {
      const id = decodeURIComponent(pathname.slice('/api/posts/'.length));
      const payload = normalizePostInput(await readJsonBody(req));
      if (!isValidPostInput(payload)) {
        return sendJson(res, 400, { error: 'title, description, and category are required' });
      }

      const data = loadData();
      const postIndex = data.posts.findIndex((item) => String(item.id) === id);
      if (postIndex === -1) return sendJson(res, 404, { error: 'Post not found' });

      const updated = {
        ...data.posts[postIndex],
        ...payload,
        updatedAt: new Date().toISOString()
      };

      data.posts[postIndex] = updated;
      data.settings.lastModified = updated.updatedAt;
      saveData(data);
      return sendJson(res, 200, updated);
    }

    if (req.method === 'DELETE' && pathname.startsWith('/api/posts/')) {
      const id = decodeURIComponent(pathname.slice('/api/posts/'.length));
      const data = loadData();
      const before = data.posts.length;
      data.posts = data.posts.filter((item) => String(item.id) !== id);

      if (data.posts.length === before) {
        return sendJson(res, 404, { error: 'Post not found' });
      }

      data.settings.lastModified = new Date().toISOString();
      saveData(data);
      return sendJson(res, 200, { success: true });
    }

    if (req.method === 'GET' && pathname === '/api/settings') {
      return sendJson(res, 200, loadData().settings);
    }

    if (req.method === 'PUT' && pathname === '/api/settings') {
      const payload = await readJsonBody(req);
      const data = loadData();
      data.settings = {
        ...data.settings,
        adsenseCode: String(payload && payload.adsenseCode ? payload.adsenseCode : ''),
        analyticsCode: String(payload && payload.analyticsCode ? payload.analyticsCode : ''),
        lastModified: new Date().toISOString()
      };
      saveData(data);
      return sendJson(res, 200, data.settings);
    }

    if (req.method === 'POST' && pathname === '/api/upload-image') {
      ensureUploadDir();
      const payload = await readJsonBody(req);
      const parsed = parseDataUrl(payload.dataUrl);
      if (!parsed) {
        return sendJson(res, 400, { error: 'Invalid image data URL' });
      }

      const ext = extensionFromMime(parsed.mime);
      if (!ext) {
        return sendJson(res, 400, { error: 'Only png, jpg, gif, and webp are supported' });
      }

      const safeBase = sanitizeFilename(payload.filename || 'image').replace(/\.[a-zA-Z0-9]+$/, '');
      const fileName = `${Date.now()}-${safeBase}.${ext}`;
      const fullPath = path.join(UPLOAD_DIR, fileName);
      const buffer = Buffer.from(parsed.base64, 'base64');
      fs.writeFileSync(fullPath, buffer);

      return sendJson(res, 201, {
        path: `assets/images/uploads/${fileName}`
      });
    }

    if (req.method === 'POST' && pathname === '/api/reset') {
      const current = loadData();
      const resetData = {
        adminPin: current.adminPin || '3003',
        posts: [],
        settings: {
          adsenseCode: '',
          analyticsCode: '',
          lastModified: new Date().toISOString()
        }
      };
      saveData(resetData);
      return sendJson(res, 200, { success: true, posts: [] });
    }

    return sendJson(res, 404, { error: 'API route not found' });
  } catch (error) {
    return sendJson(res, 500, { error: error.message || 'Internal server error' });
  }
}

function handleStatic(req, res, pathname) {
  const requestedPath = pathname === '/' ? '/index.html' : pathname;
  const normalizedPath = path.normalize(decodeURIComponent(requestedPath)).replace(/^([.][.][/\\])+/, '');
  const filePath = path.join(ROOT_DIR, normalizedPath);

  if (!filePath.startsWith(ROOT_DIR)) {
    return sendText(res, 404, '404 Not Found');
  }

  fs.readFile(filePath, (err, data) => {
    if (err) {
      return sendText(res, 404, '404 Not Found');
    }

    res.writeHead(200, { 'Content-Type': contentTypeFor(filePath) });
    res.end(data);
  });
}

const server = http.createServer(async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  const url = new URL(req.url, `http://${req.headers.host}`);
  const pathname = url.pathname;

  if (pathname.startsWith('/api/')) {
    await handleApi(req, res, pathname);
    return;
  }

  handleStatic(req, res, pathname);
});

server.listen(PORT, () => {
  console.log(`Static server running on http://localhost:${PORT}`);
  console.log(`Serving project files from: ${ROOT_DIR}`);
  console.log('Data persistence: assets/js/data.js + assets/images/uploads/');
});
